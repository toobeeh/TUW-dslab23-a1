package dslab.util.tcp;

import dslab.data.*;
import dslab.data.annotations.CommandPacketId;
import dslab.data.annotations.ProcessCommandPacket;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.net.ProtocolException;
import java.util.HashMap;

class InvalidPacketException extends Exception {
    public InvalidPacketException() {
        super("The packet command did not match any known commands");
    }
}

/**
 * A class that provides comprehensive parsing of data packages.
 * Incoming packages contain only of a String; this class checks all provided handlers
 * (processor methods implemented in subclasses) to match the incoming data.
 * Then, the packet is parsed for the handler and the handler executed.
 *
 * The handler methods have to be implemented in the deriving class.
 * Each handler needs an annotation ProcessCommandPacket which
 * registers the handler specifically for this packet type.
 * Handlers need to return strings.
 * The deriving classes effectively implement a specific
 * protocol which connect handlers with state.
 *
 * Annotation type checks are performed extensively at runtime.
 */
public abstract class PacketProtocol {

    interface PacketFactory<TPacket extends Packet> {
        TPacket create(String data) throws PacketParseException;
    }

    interface PacketHandler<TPacket extends Packet> {
        String handle(TPacket packet) throws PacketProcessException;
    }

    private HashMap<String, PacketHandler> packetHandlers = new HashMap<>();
    private HashMap<String, PacketFactory> packetFactories = new HashMap<>();

    public PacketProtocol(){

        // get packet handlers
        Method[] methods = this.getClass().getMethods();
        for (Method method : methods) {
            if (method.isAnnotationPresent(ProcessCommandPacket.class)) {

                // check if method signature is valid
                validateCommandPacketProcessor(method);

                // get packet type that the method handles (annotation is present as of previous if statement)
                var processorAnnotation = method.getAnnotation(ProcessCommandPacket.class);
                Class<? extends Packet> packetType = processorAnnotation.value();
                validateCommandPacketType(packetType);

                // get the identification of the packet
                var packetIdentification = packetType.getAnnotation(CommandPacketId.class);
                if(packetIdentification == null) throw new RuntimeException("No identification annotation present for packet class");
                String identification = packetIdentification.value();

                // register handler and factory
                this.packetFactories.put(identification, getPacketFactory(packetType));
                this.packetHandlers.put(identification, data -> {
                    try {
                        return method.invoke(this, data).toString();
                    } catch (IllegalAccessException e) {
                        throw new RuntimeException(e);
                    } catch (InvocationTargetException e) {

                        // check if exception was a processing exception and hand over
                        if(e.getTargetException() instanceof PacketProcessException) {
                            throw (PacketProcessException) e.getTargetException();
                        }
                        throw new RuntimeException(e);
                    }
                });
            }
        }
    }

    /**
     * Handle an incoming plain-text packet by the implemented protocol
     * @param data the packet text
     * @return the response, generated by the packet handler
     * @throws InvalidPacketException
     */
    public String handle(String data) {
        Packet packet = null;
        try {
            packet = this.createPacketFromString(data);
        } catch (PacketProtocolException e) {

            // handle invalid packets
            return "error protocol error";
        } catch (PacketParseException e) {

            // handle parsing errors
            return "error " + e.getResponseString();
        }
        String identification = packet.getClass().getAnnotation(CommandPacketId.class).value(); // is present as of constructor checks

        // the handler should have the right signature as it is checked in the constructor
        // if no handler, its a protocol error
        var handler = this.packetHandlers.get(identification);
        if(handler == null) {
            return "error protocol error";
        }

        String result;
        try {
            result = handler.handle(packet);
        }
        catch(PacketProcessException e) {

            // if packet could not be processed, return error message
            return "error " + e.getResponseString();
        }
        return result;
    }


    /**
     * gets the right packet class for the incoming data and creates an packet instance
     * @param data incoming plain packet data string
     * @return the parsed packet object
     * @throws InvalidPacketException
     */
    private Packet createPacketFromString(String data) throws PacketProtocolException, PacketParseException {
        String identification = data.split(" ")[0];
        var factory = this.packetFactories.get(identification);
        if(factory == null) {
            throw new PacketProtocolException();
        }

        return factory.create(data);
    }

    /**
     * validates a found packet handler method
     * @param candidate a packet processor/handler method
     */
    private void validateCommandPacketProcessor(Method candidate){

        var paramTypes = candidate.getParameterTypes();
        if(paramTypes.length != 1 || paramTypes.length > 0 && !Packet.class.isAssignableFrom(paramTypes[0])){
            throw new IllegalArgumentException("packet processor must only have exactly one argument of type Packet");
        }
        if(!String.class.isAssignableFrom(candidate.getReturnType())){
            throw new IllegalArgumentException("packet processor must only return a string");
        }
    }

    /**
     * validates a class which has been annotated with a commandpacket id
     * @param candidate the class that is a candidate for a command packet
     */
    private void validateCommandPacketType(Class<? extends Packet> candidate) {

        if(!Packet.class.isAssignableFrom(candidate)) throw new IllegalArgumentException("packet candidate needs to implement packet interface");

        try {
            var constructorParamTypes = candidate.getConstructor().getParameterTypes();
            if(constructorParamTypes.length != 0) throw new IllegalArgumentException("packet candidate constructor must not have arguments");
        }
        catch(NoSuchMethodException e) {
            // thats okay, it just doesnt have to take params
        }
    }

    /**
     * creates a new instance of a factory class
     * @param clazz the factory class
     * @return the created instance
     */
    private PacketFactory getPacketFactory(Class<? extends Packet> clazz){
        try {
            var constructor = clazz.getConstructor();
            return data -> {
                Packet packet;
                try{
                    packet = constructor.newInstance();
                }
                catch (Exception e) {
                    throw new RuntimeException(e);
                }
                return packet.parseString(data);
            };
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
}
