package dslab.util.tcp;

import dslab.data.*;
import dslab.data.annotations.CommandPacket;
import dslab.data.annotations.CommandPacketHandler;
import dslab.data.exceptions.PacketParseException;
import dslab.data.exceptions.PacketHandleException;
import dslab.data.exceptions.PacketProtocolException;
import dslab.util.tcp.exceptions.ProtocolCloseException;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.HashMap;


/**
 * A class that provides comprehensive parsing of data packages.
 * Incoming packages contain only of a String; this class checks all provided handlers
 * (processor methods implemented in subclasses) to match the incoming data.
 * Then, the packet is parsed for the handler and the handler executed.
 *
 * The handler methods have to be implemented in the deriving class.
 * Each handler needs an annotation ProcessCommandPacket which
 * registers the handler specifically for this packet type.
 * Handlers can either return string or void (which will
 * produce the packet's default response)
 * The deriving classes effectively implement a specific
 * protocol which connect handlers with state.
 *
 * Annotation type checks are performed extensively at runtime.
 */
public abstract class PacketProtocol {

    interface PacketFactory<TPacket extends Packet> {
        TPacket create(String data) throws PacketParseException, PacketProtocolException;
    }

    interface PacketHandler<TPacket extends Packet> {
        String handle(TPacket packet) throws PacketHandleException, ProtocolCloseException;
    }

    private HashMap<String, PacketHandler> packetHandlers = new HashMap<>();
    private HashMap<String, PacketFactory> packetFactories = new HashMap<>();
    protected abstract boolean protocolErrorIsFatal();

    public PacketProtocol(){

        // get packet handlers
        Method[] methods = this.getClass().getMethods();
        for (Method method : methods) {
            if (method.isAnnotationPresent(CommandPacketHandler.class)) {

                // check if method signature is valid
                var packetType = validateCommandPacketHandler(method);

                // validate packet type that the method handles
                validateCommandPacketType(packetType);

                // get the identification of the packet
                var packetIdentification = packetType.getAnnotation(CommandPacket.class);
                if(packetIdentification == null) throw new RuntimeException("No identification annotation present for packet class");
                String identification = packetIdentification.value();

                // register handler and factory
                this.packetFactories.put(identification, getPacketFactory(packetType));
                this.packetHandlers.put(identification, getPacketHandler(method));
            }
        }
    }

    /**
     * Handle an incoming plain-text packet by the implemented protocol
     * @param data the packet text
     * @return the response, generated by the packet handler
     */
    public String handle(String data) throws ProtocolCloseException {
        Packet packet = null;
        try {
            packet = this.createPacketFromString(data);
        } catch (PacketProtocolException e) {

            // handle invalid packets
            if(protocolErrorIsFatal()) throw new ProtocolCloseException("error protocol error");
            return "error protocol error";
        } catch (PacketParseException e) {

            // handle parsing errors
            return "error " + e.getResponseString();
        }
        String identification = packet.getClass().getAnnotation(CommandPacket.class).value(); // is present as of constructor checks

        // the handler should have the right signature as it is checked in the constructor
        // if no handler, its a protocol error
        var handler = this.packetHandlers.get(identification);
        if(handler == null) {
            if(protocolErrorIsFatal()) throw new ProtocolCloseException("error protocol error");
            return "error protocol error";
        }

        String result;
        try {
            // handle packet and use packet response if no other return provided by handler
            result = handler.handle(packet);
            if(result == null) result = packet.getResponseString();
        }
        catch(PacketHandleException e) {

            // if packet could not be processed, return error message
            return "error " + e.getResponseString();
        }
        return result;
    }


    /**
     * gets the right packet class for the incoming data and creates an packet instance
     * @param data incoming plain packet data string
     * @return the parsed packet object
     */
    private Packet createPacketFromString(String data) throws PacketProtocolException, PacketParseException {
        String identification = data.split(" ")[0];
        var factory = this.packetFactories.get(identification);
        if(factory == null) {
            throw new PacketProtocolException();
        }

        return factory.create(data);
    }

    /**
     * validates a found packet handler method
     * @param candidate a packet processor/handler method
     */
    private Class<? extends Packet> validateCommandPacketHandler(Method candidate){

        var paramTypes = candidate.getParameterTypes();
        if(paramTypes.length != 1 || paramTypes.length > 0 && !Packet.class.isAssignableFrom(paramTypes[0])){
            throw new IllegalArgumentException("packet processor must only have exactly one argument of type Packet");
        }
        if(!String.class.isAssignableFrom(candidate.getReturnType()) && !candidate.getReturnType().equals(void.class)){
            throw new IllegalArgumentException("packet processor must only return a string or void");
        }
        return (Class<? extends Packet>) paramTypes[0];
    }

    /**
     * validates a class which has been annotated with a commandpacket id
     * @param candidate the class that is a candidate for a command packet
     */
    private void validateCommandPacketType(Class<? extends Packet> candidate) {

        if(!Packet.class.isAssignableFrom(candidate)) throw new IllegalArgumentException("packet candidate needs to implement packet interface");

        try {
            var constructorParamTypes = candidate.getConstructor().getParameterTypes();
            if(constructorParamTypes.length != 0) throw new IllegalArgumentException("packet candidate constructor must not have arguments");
        }
        catch(NoSuchMethodException e) {
            // thats okay, it just doesnt have to take params
        }
    }

    /**
     * creates a new instance of a factory class
     * @param clazz the factory class
     * @return the created instance
     */
    private PacketFactory getPacketFactory(Class<? extends Packet> clazz){
        try {
            var constructor = clazz.getConstructor();
            return data -> {
                Packet packet;
                try{
                    packet = constructor.newInstance();
                }
                catch (Exception e) {
                    throw new RuntimeException(e);
                }
                return packet.parseString(data);
            };
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    /**
     * builds a lambda that invokes a packet handler and returns its result
     * @param method the handler method
     * @return a lambda which invokes the handler
     */
    private PacketHandler getPacketHandler(Method method){
        return data -> {
            try {
                var result = method.invoke(this, data);
                return result == null ? null : result.toString();
            } catch (IllegalAccessException e) {
                throw new RuntimeException(e);
            } catch (InvocationTargetException e) {

                // check if exception was a processing exception and hand over
                if(e.getTargetException() instanceof PacketHandleException) {
                    throw (PacketHandleException) e.getTargetException();
                }

                // check if handler termianted connection
                if(e.getTargetException() instanceof ProtocolCloseException) {
                    throw (ProtocolCloseException) e.getTargetException();
                }
                throw new RuntimeException(e);
            }
        };
    }
}
