package dslab.util.tcp;

import dslab.data.*;
import dslab.data.annotations.CommandPacketId;
import dslab.data.annotations.ProcessCommandPacket;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.HashMap;

class InvalidPacketException extends Exception {
    public InvalidPacketException() {
        super("The packet command did not match any known commands");
    }
}

/**
 * A class that provides comprehensive parsing of data packages.
 * Incoming packages contain only of a String; this class checks all provided handlers
 * (processor methods implemented in subclasses) to match the incoming data.
 * Then, the packet is parsed for the handler and the handler executed.
 *
 * The handler methods have to be implemented in the deriving class.
 * Each handler needs an annotation ProcessCommandPacket which
 * registers the handler specifically for this packet type.
 * Handlers need to return strings.
 *
 * Annotation type checks are performed extensively at runtime.
 */
public abstract class PacketParser {

    interface PacketFactory<TPacket extends Packet> {
        TPacket create(String data) throws InvocationTargetException, InstantiationException, IllegalAccessException;
    }

    private HashMap<String, Method> packetHandlers = new HashMap<>();
    private HashMap<String, PacketFactory> packetFactories = new HashMap<>();


    public PacketParser(){

        // get packet handlers
        Method[] methods = this.getClass().getMethods();
        for (Method method : methods) {
            if (method.isAnnotationPresent(ProcessCommandPacket.class)) {

                // check if method signature is valid
                validateCommandPacketProcessor(method);

                // get packet type that the method handles (annotation is present as of previous if statement)
                var processorAnnotation = method.getAnnotation(ProcessCommandPacket.class);
                Class<? extends Packet> packetType = processorAnnotation.value();
                validateCommandPacketType(packetType);

                // get the identification of the packet
                var packetIdentification = packetType.getAnnotation(CommandPacketId.class);
                if(packetIdentification == null) throw new RuntimeException("No identification annotation present for packet class");
                String identification = packetIdentification.value();

                // register handler and factory
                this.packetFactories.put(identification, getPacketFactory(packetType));
                this.packetHandlers.put(identification, method);
            }
        }
    }

    /**
     * Parse an incoming plain-text packet
     * @param data the packet text
     * @return the response, generated by the packet handler
     * @throws InvalidPacketException
     */
    public String parse(String data) throws InvalidPacketException {
        var packet = this.createPacketFromString(data);
        String identification = packet.getClass().getAnnotation(CommandPacketId.class).value(); // is present as of constructor checks

        // the handler should have the right signature as it is checked in the constructor
        var handler = this.packetHandlers.get(identification);
        if(handler == null) {
            System.err.println("Unknown packet");
            throw new InvalidPacketException();
        }

        String result;
        try {
            result = (String) handler.invoke(this, packet);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
        return result;
    }


    /**
     * gets the right packet class for the incoming data and creates an packet instance
     * @param data incoming plain packet data string
     * @return the parsed packet object
     * @throws InvalidPacketException
     */
    private Packet createPacketFromString(String data) throws InvalidPacketException {
        String identification = data.split(" ")[0];
        var factory = this.packetFactories.get(identification);
        if(factory == null) {
            System.err.println("Unknown packet");
            throw new InvalidPacketException();
        }

        Packet packet;
        try{
            packet = factory.create(data);
        }
        catch (Exception e){
            System.err.println("Invalid packet");
            throw new InvalidPacketException();
        }

        return packet;
    }

    /**
     * validates a found packet handler method
     * @param candidate a packet processor/handler method
     */
    private void validateCommandPacketProcessor(Method candidate){

        var paramTypes = candidate.getParameterTypes();
        if(paramTypes.length != 1 || paramTypes.length > 0 && !Packet.class.isAssignableFrom(paramTypes[0])){
            throw new IllegalArgumentException("packet processor must only have exactly one argument of type Packet");
        }
        if(!String.class.isAssignableFrom(candidate.getReturnType())){
            throw new IllegalArgumentException("packet processor must only return a string");
        }
    }

    /**
     * validates a class which has been annotated with a commandpacket id
     * @param candidate the class that is a candidate for a command packet
     */
    private void validateCommandPacketType(Class<? extends Packet> candidate) {

        if(!Packet.class.isAssignableFrom(candidate)) throw new IllegalArgumentException("packet candidate needs to implement packet interface");

        try {
            var constructorParamTypes = candidate.getConstructor().getParameterTypes();
            if(constructorParamTypes.length != 0) throw new IllegalArgumentException("packet candidate constructor must not have arguments");
        }
        catch(NoSuchMethodException e) {
            // thats okay, it just doesnt have to take params
        }
    }

    /**
     * creates a new instance of a factory class
     * @param clazz the factory class
     * @return the created instance
     */
    private PacketFactory getPacketFactory(Class<? extends Packet> clazz){
        try {
            var constructor = clazz.getConstructor();
            return data -> constructor.newInstance().parseString(data);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
}
